### 面试题 08.11.硬币（中等）

硬币。给定数量不限的硬币，币值为 25 分、10 分、5 分和 1 分，编写代码计算 n 分有几种表示法。(结果可能会很大，你需要将结果模上 1000000007)

示例 1:

```text
输入: n = 5
输出：2
解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

示例 2:

```text
输入: n = 10
输出：4
解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

说明：

你可以假设：

- 0 <= n (总金额) <= 1000000

**注**
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/coin-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

#### 提交

```py
# Python3
class Solution:
    def waysToChange(self, n: int) -> int:
        n = n // 5
        ans = 0
        while n >= 0:
            ans = (ans + (n//2+1)*((n+1)//2+1))
            n -= 5
        return ans % 1000000007
```

#### 参考

##### 方法一：动态规划

**思路**

首先考虑一个朴素的方法，我们用 f(i, v) 来表示前 i 种面值的硬币构成面值为 v 的方案数量，用 c_i 来表示第 i 种面值的硬币的面值。

我们可以从 f(i - 1, v - 0 × c_i), f(i - 1, v - 1 × c_i), f(i - 1, v - 2 × c_i) ... f(i - 1, v - k × c_i) 转移得到，它们表示第 i 个面值的硬币选 0, 1, 2 ... k 个的时候，构成面值为 v 的方案数量，其中 k 为满足 v - k × c_i ≥ 0 的最大整数。于是我们可以推导出这样的动态规划转移方程：

```text
          k
f(i, v) = ∑ f(i − 1,v − j × c_i), k = ⌊ v/c_i ⌋
         j=0
```

这个方程表示什么意思呢？ 这个方程表示前 i 种硬币，构成面值 v 的方案数量由前 i - 1 种面值构成的一些面值的方案数量决定。我们可以考虑 c_i 取多少个，c_i 可以取 0 个、1 个、2 个......最大可以取 ⌊ v/c_i ⌋ 个，那么前 i 种硬币，构成面值 v 的方案数量就是如下项的累加：前 i - 1 种硬币构成面值 v 的方案数量（表示不取 c_i），前 i - 1 种硬币构成面值 v - c_i 的方案数量（表示取 1 个 c_i ），前 i - 1 种硬币构成面值 v - 2 × c_i 的方案数量（表示取 2 个 c_i），前 i - 1 种硬币构成面值 v - ⌊ v/c_i ⌋ × c_i 的方案数量（表示取 ⌊ v/c_i ⌋ 个 c_i）。

举个例子。 假设这里 c = {1, 5, 10, 25}，在 i = 4 的时候，c_i = 25（假设下标从 1 开始），如果我们要求前 4 种面值构成 90 的方案数量，可以这么写：

```text
f(4, 90) = f(3, 90) + f(3, 90 - 25) + f(3, 90 - 2 × 25) + f(3, 90 - 3 × 25)
```

这里最多取 3 个 25，所以等式右边一共有四项，分别代表取 0、1、2、3 个 25，即从前 3 种面值构成 90、90 - 25、90 - 2 × 25、90 − 3 × 25 四个状态中进行选择。

在实现这样一个转移方程的时候，i 的取值有 4 种，v 的取值有 n + 1 种，所以状态总数是 4(n + 1)，我们需要用到 O(4 × (n + 1)) 的空间代价来存取状态。对于每一个状态，我们需要在区间 [0, k] 枚举 j，所以计算单个状态的时间代价是 O(⌊ v/c_i ⌋)，所以总的时间代价是 O(4 × (n + 1) × ⌊ v/c_i ⌋)。于是我们就可以用三重循环来实现这个朴素的转移方程。

考虑优化方法。

第一步考虑优化时间复杂度。 我们可以把求和式展开书写：

```text
f(i, v) = f(i − 1, v) + f(i − 1, v − c_i ) + f(i − 1, v − 2c_i )⋯f(i − 1, v − kc_i)
```

共 k + 1 项，其中 k = ⌊ v/c_i ⌋。那么我们可以得到使用 v - c_i 替换 v，得到：

```text
f(i, v - c_i) = f(i - 1, v - c_i) + f(i - 1, v - 2c_i) + f(i - 1, v - 3c_i) ... f(i - 1, v - kc_i)
```

共 k 项。注意到上面两个方程中标成红色的 k 项是完全相同的，于是我们可以用下面式子的左半部分 f(i, v - c_i) 等价替换上面式子红色的 k 项，得到化简后的转移方程：

```text
f(i, v) = f(i - 1, v) + f(i, v - c_i)
```

这样我们就可以把原来的三重循环变成两重循环，求解每个状态的时间代价是 O(1)，总的时间代价为 O(4 × (n + 1))。

第二步考虑优化空间复杂度。 朴素实现的时候我们需要一个 4 × (n + 1) 的二维数组。观察方程 f(i, v) = f(i - 1, c_i) + f(i, v - c_i)，更新二维数组的第 i 行只和第 i - 1 相关，我们不关心 [0, i - 2] 行——于是我们可以用「滚动数组」思想来优化这个过程。实现的方法有两种。

- 用两个一维数组来实现转移：通过 i 和 i - 1 的奇偶性相反来实现，即当求到第 i 行那一轮的时候，把第 (i mod 2) xor 1 行当作是 i - 1 行，这样就只需要两行，循环利用。

- 用一个一维数组来实现转移：我们用数组 F[0 ... n] 表示，我们在第 i 轮计算之前 i - 1 轮的答案保存在 F 数组中，F[v] 保存的是 i - 1 轮 f(i - 1, v) 的值，在第 i 轮计算结束后，它将保存 f(i, v) 的值。假设第二维从小到大更新，因为 f(i, v) 只和 f(i, v - c_i) 和 f(i - 1, v) 相关，在计算 f(i, v) 但是还没有更新 F[v] 值的时候，F[v] 保存的是上一轮的答案 f(i - 1, v)，而 F[0 ... v - 1]中保存的是 f(i, v'), v' ∈ [0, v − 1] 的值，f(i, v - c_i) 包含在其中，所以这么做是可行的。代码中给出了这种方法的实现，如果这里看不懂可以结合代码。

这样一来，空间代价就可以从 O(4 × (n + 1)) 变成 O(2 × (n + 1)) 或者 O(n + 1)。

其实这个问题是两个非常经典的问题的组合，其一是「完全背包问题」，其二是「背包方案数问题」，如果读者感兴趣的话可以自行阅读《背包九讲》。掌握了这些常见的背包问题的模型，你对动态规划的理解将更进一步。

**代码**

```py
# Python3
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7
        coins = [25, 10, 5, 1]

        f = [1] + [0] * n
        for coin in coins:
            for i in range(coin, n + 1):
                f[i] += f[i - coin]
        return f[n] % mod
```

```c++
// C++
class Solution {
private:
    static constexpr int mod = 1000000007;
    static constexpr int coins[4] = {25, 10, 5, 1};

public:
    int waysToChange(int n) {
        vector<int> f(n + 1);
        f[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                f[i] = (f[i] + f[i - coin]) % mod;
            }
        }
        return f[n];
    }
};
```

```golang
// Golang
func waysToChange(n int) int {
    dp := make([]int, n + 1)
    dp[0] = 1
    coins := []int{1, 5, 10, 25}
    for i := 0; i < 4; i++ {
        for j := 1; j <= n; j++ {
            if j - coins[i] >= 0 {
                dp[j] += dp[j - coins[i]]
            }
        }
    }
    return dp[n] % 1000000007
}
```

**复杂度**

- 时间复杂度：上文分析过，方程化简之后的渐进时间复杂度为 O(4 × (n + 1)) = O(n)。

- 空间复杂度：使用滚动数组思想优化后，只需要使用一个长度为 n + 1 的一维数组，故渐进空间复杂度为 O(n)。

##### 方法二：数学

**思路**

对于给定的 n，我们先枚举 25 分的硬币的个数 i，那么剩下的部分我们记为 r = n - 25 × i，r 可以表示成：

```text
r = 10 × a + 5 × b + c
```

这里 a 能取的最大值 a_0 = ⌊ r/10 ⌋，当 a = a_0 时限定 c < 5 可以得到这种情况下 b 的最大值 b_0，那么令 c_0 = r - 10 × a_0 - 5 × b_0。

考虑选择 i 个 25 分硬币的时候的情况，假设我们选择 x 个 10 分硬币，那么还剩下的金额我们可以表示成：

```text
10 × (a_0 - x) + 5 × b_0 + c_0
```

考虑把 10 × (a_0 - x) 这一项全部用 5 分硬币来替代，即上面的式子可以化成 5 (2a_0 - 2x + b_0) + c_0，那么 5 分硬币可以选择的范围是 [0, 2a_0 - 2x + b_0]，剩下的用 1 分硬币补齐。也就是说对于 25 分取 i 个，10 分取 x 个的时候方案总数为 2a_0 - 2x + b_0 + 1，根据等差数列求和的方法，对 x 求和：

```text
a_0
 ∑ (2a_0 - 2x + b_0 + 1) = (a_0 + 1)(a_0 + b_0 + 1)
x=0
```

我们就可以得到 25 分取 i 个的时候的方案总数，枚举 i 并累加即可得到最终的答案。

**代码**

```py
# Python3
class Solution:
    def waysToChange(self, n: int) -> int:
        mod = 10**9 + 7

        ans = 0
        for i in range(n // 25 + 1):
            rest = n - i * 25
            a, b = rest // 10, rest % 10 // 5
            ans += (a + 1) * (a + b + 1)
        return ans % mod
```

```c++
// C++
class Solution {
private:
    static constexpr int mod = 1000000007;

public:
    int waysToChange(int n) {
        int ans = 0;
        for (int i = 0; i * 25 <= n; ++i) {
            int rest = n - i * 25;
            int a = rest / 10;
            int b = rest % 10 / 5;
            ans = (ans + (long long)(a + 1) * (a + b + 1) % mod) % mod;
        }
        return ans;
    }
};
```

```golang
// Golang
func waysToChange(n int) int {
    ans := 0
    mod := 1000000007
    for i := 0; i * 25 <= n; i++ {
        rest := n - i * 25
        a, b := rest/10, rest%10/5
        ans = (ans + (a + 1) * (a + b + 1) % mod) % mod
    }
    return ans
}
```

**复杂度**

- 时间复杂度：这里只使用了一重循环，循环的次数为 ⌊ n/25 ⌋，所以渐进时间复杂度为 O(⌊ n/25 ⌋) = O(n)。
- 空间复杂度：没有使用辅助数组，只用了常数个临时变量（与问题规模 n 无关），故渐进空间复杂度为 O(1)。

**注**
作者：LeetCode-Solution
链接：<https://leetcode-cn.com/problems/coin-lcci/solution/ying-bi-by-leetcode-solution/>
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
